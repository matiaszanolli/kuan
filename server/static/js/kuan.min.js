(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
$(document).ready(function()
{
  var game = require('./game'),
  profiler_enabled = (document.getElementById('profile') !== null);

  // Set up the graphics system

  var screen_ctx = document.getElementById('c').getContext('2d');

  var screen_ui = $('#c');

  var w = document.getElementById('c').width;
  var h = document.getElementById('c').height;

  var render_ctx, render_canvas;
  if (game.options_flags.double_buffer)
  {
    // Create temporary canvas for double-buffering
    render_canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
    render_canvas.width = w;
    render_canvas.height = h;
    render_ctx = render_canvas.getContext('2d');
  }
  else
  {
    // Draw directly onto the screen
    render_ctx = screen_ctx;
  }

  if (game.options_flags.opera_context)
  {
    try
    {
      var gctx = document.getElementById('c').getContext('opera-2dgame');
      if (gctx)
      {
        gctx.lockCanvasUpdates(true);
      }
    }
    catch (e)
    {
      // context not available
    }
  }

  var dctx;
  if (game.options_flags.map && document.getElementById('dc'))
  {
    dctx = document.getElementById('dc').getContext('2d');
    dctx.lineWidth = 1/map_scale;
    dctx.translate(map_shift_x+dctx.canvas.width/2, map_shift_y+dctx.canvas.height/2);
    dctx.scale(map_scale, map_scale);
  }

  // Allow resolution changes

  window.change_res = function (new_w, new_h)	{
    w = new_w;
    h = new_h;
    if (render_ctx != screen_ctx)
    {
      render_canvas.width = w;
      render_canvas.height = h;
    }
    document.getElementById('c').width = w;
    document.getElementById('c').height = h;
    game.preprocess_map(render_ctx, h);
  };

  //////
/*
  if (document.getElementById('options'))
  {
    var options = [
      [ 'gradient_surfaces', 'Gradient floor/ceiling', [0, 1], function(){ preprocess_map(ctx, h); } ],
      [ 'lighting_workaround', 'Alternate lighting (workaround for Opera)', [0, 1] ],
      [ 'horizontal_scale', 'Horizontal raycasting scale', [1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32] ],
      [ 'low_textures', 'Low detail textures', [1, 0], function(){ flush_textures(); preprocess_map(ctx, h); } ]
    ];
    var options_html = '';
    for (var o in options)
    {
      options_html += '<select id="options__'+options[o][0]+'">';
      var choices = options[o][2];
      for (var c in choices)
      {
        options_html += '<option value="'+choices[c]+'">'+choices[c]+'</option>';
      }
      options_html += '</select> - <b>'+options[o][1]+'</b><br/>';
    }
    document.getElementById('options').innerHTML = options_html;
    for (var o in options)
    {
      var obj = document.getElementById('options__'+options[o][0]);
      for (var i in obj.options)
      {
        if (obj.options[i].value == options_flags[options[o][0]])
        {
          obj.selectedIndex = i;
          break;
        }
      }
      (function(){
        var option = options[o];
        obj.onchange = function (e)
        {
          options_flags[option[0]] = Math.floor(this.options[this.selectedIndex].value);
          if (option[3]) { option[3](); }
        };
      })();
    }
  }
*/

  //////

  // Per-frame operation and pausing

  var last_frame_time = null; // should only be non-null while the game is running (not paused)
  function tick()
  {
    try
    {
      var now = new Date();
      var dt = Math.max(0, now - (last_frame_time || now)) / 1000;
      last_frame_time = now;
      // TODO: smoother updates, particularly on Windows where the timer
      // is limited to ~16msec resolution

      game.game_tick(render_ctx, dctx, gctx, w, h, keys, dt);
      if (render_ctx !== screen_ctx)
      {
        screen_ctx.drawImage(render_canvas, 0, 0);
      }

      profile_report();
      framerate_update();
      write_status_data(status_data);
    }
    catch (e)
    {
      debug(e);
    }
  }

  var paused = true;

  var frame_interval;
  function toggle_paused()
  {
    paused = !paused;
    if (paused)
    {
      render_paused(screen_ctx, w, h);
      clearInterval(frame_interval);
      last_frame_time = null;
    }
    else
    {
      frame_interval = setInterval(tick, game.editor_enabled ? 100 : 0);
    }
  }

  document.getElementById('pause').onclick = toggle_paused;

  var status_data = {};

  //////

  // Set up input handlers

  $('#c').mousemove(function(event) {
    if (Math.abs(event.pageX - game.current_x) > 10) {
      // Si hay un cambio grande de posicion
      game.current_x = 0;
    } else {
      game.current_x = event.pageX - game.current_x;
    }
  });


  document.addEventListener("mousemove", function(e){
    cursor_move.x = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
    cursor_move.y = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
    status_data.move_x = cursor_move.x;
    status_data.move_y = cursor_move.y;
  }, false);
  if (dctx)
  {
    /*document.getElementById('dc').onmousemove = function(e)
    {
      var x = e.clientX-this.offsetLeft;
      var y = e.clientY-this.offsetTop;
      status_data.mouse_x = x;
      status_data.mouse_y = y;
      x -= player.x*map_scale + map_shift_x + dctx.canvas.width/2;
      y -= player.y*map_scale + map_shift_y + dctx.canvas.height/2;
      var mag = Math.sqrt(x*x + y*y);
      x /= mag;
      y /= mag;
      player.dx = x;
      player.dy = y;
    };*/

    document.getElementById('dc').onclick = function(e)
    {
      var x = e.clientX-this.offsetLeft;
      var y = e.clientY-this.offsetTop;
      move_camera((x - map_shift_x - dctx.canvas.width/2) / map_scale-player.x,
                  (y - map_shift_y - dctx.canvas.height/2) / map_scale-player.y);
    };
  }

  var keys = {};
  document.addEventListener('keydown', function(e)
  {
    keys[e.keyCode] = true;
  },
  false);

  document.addEventListener('keyup', function(e)
  {
    keys[e.keyCode] = false;
  },
  false);

  document.addEventListener('keypress', function(e)
  {
    // TODO: the keycode values are completely nonstandard - is
    // there a more reliable way of handling them?

    var handled = true;
    switch (e.keyCode)
    {
    case DOM_VK.LEFT: case DOM_VK.RIGHT:
    case DOM_VK.UP: case DOM_VK.DOWN:
    case DOM_VK.PAGE_UP: case DOM_VK.PAGE_DOWN:
    case DOM_VK.COMMA: case DOM_VK.PERIOD:
    case DOM_VK.DELETE:
      // Browsers might want to do something with these keys
      // (especially Opera) - but we want to use them instead,
      // so prevent the default action
      handled = false; // don't want to stop propagation to game's key handlers
      e.preventDefault(); // do want to stop the browser's default
      break;

    case DOM_VK.PAUSE:
      toggle_paused();
      break;

    case DOM_VK.HOME: case DOM_VK.END:
      player.dh = 0;
      break;

    default:
      switch (e.which)
      {
      case 116: // T
        if (e.ctrlKey)
        {
          // let people do ctrl+t to open tabs
          handled = false;
        }
        else
        {
          fpsgraph_enable(true);
        }
        break;

      case 32: // SPACE
      case 44: case 46: // comma, period
      case 120: case 99: // x, c
        handled = false;
        e.preventDefault();
        break;

      default:
        handled = false;
        break;
      }
    }

    if (handled)
    {
      e.preventDefault();
      e.stopPropagation();
    }
  },
  false);

  //////

  if (level)
  {
    game.on_map_loaded(render_ctx, h);
  }
  else
  {
    // If no level is loaded, we load the first level
    // TODO Levels ahould be loaded dynamically
    load_from_file_store_async('map_test0',
      function (obj)
      {
        level = obj;
        game.on_map_loaded(render_ctx, h);
      }
    );
  }

  //////

  if (ui_enabled)
  {
    try
    {
      ui.init();
    }
    catch (e)
    {
      alert('UI initialisation failure: ' + e);
    }
  }

  //////

  // Start the game
  toggle_paused();

}); // $(document).ready

var previousError;

function debug(str)
{
  $('#status').val(str);
  if (str.stack != previousError) {
    console.log(str.stack);
    previousError = str.stack;
  }
}

},{"./game":2}],2:[function(require,module,exports){
/*
 * Copyright 2006 Philip Taylor
 * <philip at zaynar.demon.co.uk> / <excors at gmail.com>
 * Distributed under the terms of the GPL (http://www.gnu.org/licenses/gpl.txt)
 */

var Game = function() {
  var self = this;
	self.options_flags = require('./options_flags');
	var Renderer = require('./renderer');
	self.renderer = new Renderer(self.options_flags);

  self.max_vertical_look = 0.8;
  self.max_turn_speed = 3.0;
  self.max_mouse_movement = 60;
  self.turn_threshold = 2;

  var editor_enabled = this.editor_enabled;
  var ui_enabled = this.ui_enabled;

  self.current_x = 0;

  self.fpsgraph_enabled = false;

  self.camera = {
    x: 0, y: 0, z: 0, // position of eye
    dx: 0, dy: 0, // viewing direction (unit vector)
    dh: 0, // vertical view offset
    s: null, // current sector
    t: 0 // current time (seconds since start of game)
  };

  // 'wall': { name: [ { 'img': Image object, 'w': tile width, 'h': tile height }, ...(for increasing mipmaps) ] }
  // 'sprite': { name: { 'sprite':spritedef, images: [ Image object, ...(for frames of animation, then for directions) ] } }
  self.textures = { wall:{}, sprite:{} };
  self.loading_textures = [];

  self.default_texture = { img:new Image(), w:32, h:32 };
  self.error_texture = { img:new Image(), w:32, h:32 };
  self.default_texture.img.src = 'data:image/png;base64,' + texture_data.loading;
  self.error_texture.img.src = 'data:image/png;base64,' + texture_data.error;

  // Globals declared in renderer.js:
  //   var sectors;
  //   var sprites;
  // (TODO: do they need to be separate globals, and not part of the standard level object?)

  // Data about the current level (after passing through preprocess_map)
  // Properties:
  //  proximity_triggers: [ { x:..., y:..., fn: function(dt, dist) {...} }, ... ]
  self.level_data = {};

  function load_texture(type, name)
  {
    if (! name)
    {
      return undefined;
    }

    if (! self.textures.wall[name])
    {
      var texture_dir = 'textures/tiled/' + ((self.options_flags.draw_pattern_walls || type == 'floor' || type == 'ceiling') ? 'mip2/' : 'mip/');

      self.textures.wall[name] = [];
      if (self.options_flags.mipmap_enabled)
      {
        for (var i = self.options_flags.mipmap_min; i <= self.options_flags.mipmap_max; ++i)
        {
          var image = new Image();
          image.src = texture_dir+name+'.'+i+'.png';
          self.textures.wall[name][i] = { img:self.default_texture.img, w:self.default_texture.w, h:self.default_texture.h };
          self.loading_textures.push( { type:type, obj:self.textures.wall[name][i], img:image } );
        }
      }
      else
      {
        var image = new Image();
        image.src = texture_dir+name+'.'+self.options_flags.mipmap_max+'.png';
        self.textures.wall[name][self.options_flags.mipmap_min] = { img:self.default_texture.img, w:self.default_texture.w, h:self.default_texture.h };
        self.loading_textures.push( { type:type, obj:self.textures.wall[name][self.options_flags.mipmap_min], img:image } );
      }
    }

    return self.textures.wall[name];
  }

  function load_sprite(name)
  {
    if (! self.textures.sprite[name])
    {
      if (! spritedefs[name])
      {
        // error - sprite doesn't exist
        return null;
      }

      self.textures.sprite[name] = { sprite:spritedefs[name], images:[] };
      var i = 0;
      for (var a = 0; a < spritedefs[name].angles; ++a)
      {
        for (var f = 0; f < spritedefs[name].frames; ++f)
        {
          self.textures.sprite[name].images.push({ img:self.default_texture.img, w:self.default_texture.w, h:self.default_texture.h });

          var image = new Image();
          image.src = 'textures/sprites/'+spritedefs[name].img+'.'+a+'.'+f+'.png';
          self.loading_textures.push( { type:'sprite', obj:self.textures.sprite[name].images[i], img:image } );
          ++i;
        }
      }
    }

    return self.textures.sprite[name];
  }

  function flush_textures()
  {
    self.textures = { wall:{}, sprite:{} };
    self.loading_textures = [];
  }

  function process_pending_textures(ctx)
  {
    for (var t in self.loading_textures)
    {
      var tex = self.loading_textures[t];
      if (tex.img.complete)
      {
        if (tex.img.width)
        {
          if (self.options_flags.draw_pattern_walls && tex.type == 'wall')
          {
            tex.obj.img = ctx.createPattern(tex.img, 'repeat');

            tex.obj.w = tex.img.width; // texture_u_repeat;
            tex.obj.h = tex.img.height; // texture_v_repeat;
          }
          else
          {
            if (tex.type == 'floor')
            {
              tex.obj.img = ctx.createPattern(tex.img, 'repeat');
            }
            else if (self.options_flags.draw_from_canvas)
            {
              var canvas = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
              canvas.width = tex.img.width;
              canvas.height = tex.img.height;
              canvas.getContext('2d').drawImage(tex.img, 0, 0);
              tex.obj.img = canvas;
            }
            else
            {
              tex.obj.img = tex.img;
            }

            if (tex.type == 'wall')
            {
              tex.obj.w = tex.img.width / self.options_flags.texture_u_repeat;
              tex.obj.h = tex.img.height / self.options_flags.texture_v_repeat;
            }
            else // tex.type == 'sprite' || 'floor'
            {
              tex.obj.w = tex.img.width;
              tex.obj.h = tex.img.height;
            }
          }
        }
        else
        {
          tex.obj.img = error_texture.img;
          tex.obj.w = error_texture.w;
          tex.obj.h = error_texture.h;
        }
        delete self.loading_textures[t];
      }
    }
  }


  function array_to_rgba(c)
  {
    return 'rgba('+c[0]+','+c[1]+','+c[2]+',1)';
  }

  function colour_interpolate(c0, c1, n)
  {
    var m = 1-n;
    return [ Math.floor(c0[0]*m+c1[0]*n),
             Math.floor(c0[1]*m+c1[1]*n),
             Math.floor(c0[2]*m+c1[2]*n) ];
  }

  function scripted_vertical_door(sector)
  {
    var attached_edges = [];
    // Check all sectors attached to this one, and make a list of their
    // edges which this sector is attached to
    for (var e = 0; e < sector.edges.length; ++e)
    {
      if (sector.edges[e].dest)
      {
        var edges2 = sector.edges[e].dest.edges;
        for (var e2 = 0; e2 < edges2.length; ++e2)
        {
          if (edges2[e2].dest === sector)
          {
            attached_edges.push(edges2[e2]);
          }
        }
      }
    }

    return function (dt, dist)
    {
      var speed = 0.3;
      var h;
      if (dist < 2)
      {
        h = Math.min(1, sector.ceiling_height + speed*dt);
      }
      else
      {
        h = Math.max(0, sector.ceiling_height - speed*dt);
      }
      if (h != sector.ceiling_height)
      {
        for (var e = 0; e < attached_edges.length; ++e)
        {
          // TODO: maybe we want texture offsets?
          attached_edges[e].upper.v = h * attached_edges[e].upper.vscale;
        }
        sector.ceiling_height = h;
      }
    };
  }

  self.preprocess_map = function(ctx, h)
  {
    if (player.s)
    {
      player.sector_id = player.s.id;
    }

    sectors = [];
    self.level_data.proximity_triggers = [];

    for (var s = 0; s < level.sectors.length; ++s)
    {
      var sector = level.sectors[s];

      var new_sector = {
        id: s,
        floor_height: sector.floor_height,
        ceiling_height: sector.ceiling_height,
        light: sector.light,
        sector_id: s,
        sprites: {}
      };

      if (self.options_flags.gradient_surfaces)
      {
        var gradient;

        var dh = h * self.max_vertical_look;
        var stop0 = dh / (h+2*dh);
        var stop1 = (dh+h) / (h+2*dh);

        // Create the floor pattern
        if (! self.options_flags.textured_floors)
        {
          gradient = ctx.createLinearGradient(0, -dh, 0, h+dh);
          var c = colour_interpolate([ 0, 0, 0 ], sector.floor, sector.light);
          var c0 = array_to_rgba( colour_interpolate(c, [ 255, 255, 255 ], 0.3 ) );
          var c1 = array_to_rgba( c );
          gradient.addColorStop(1, c0);
          gradient.addColorStop(stop1, c0);
          gradient.addColorStop(0.5, c1);
          gradient.addColorStop(stop0, c1);
          gradient.addColorStop(0, c1);
          new_sector.floor = gradient;
        }
        else
        {
          new_sector.floor = load_texture('floor', 'testfloor');
        }

        // Create the ceiling pattern
        if (! self.options_flags.textured_ceilings)
        {
          // #TODO: Not working yet
          gradient = ctx.createLinearGradient(0, -dh, 0, h+dh);
          c = colour_interpolate([ 0, 0, 0 ], sector.ceiling, sector.light);
          c0 = array_to_rgba( colour_interpolate(c, [ 0, 0, 0 ], 0.3 ) );
          c1 = array_to_rgba( c );
          gradient.addColorStop(0, c0);
          gradient.addColorStop(stop0, c0);
          gradient.addColorStop(0.5, c1);
          gradient.addColorStop(stop1, c1);
          gradient.addColorStop(1, c1);
          new_sector.ceiling = gradient;
        }
        else
        {
          new_sector.ceiling = load_texture('ceiling', '2_conc_celing01');
        }
      }
      else
      {
        // No gradients - use flat colours
        c = colour_interpolate([ 0, 0, 0 ], sector.floor, sector.light);
        new_sector.floor = array_to_rgba( colour_interpolate(c, [ 255, 255, 255 ], 0.3/2 ) );
        c = colour_interpolate([ 0, 0, 0 ], sector.ceiling, sector.light);
        new_sector.ceiling = array_to_rgba( colour_interpolate(c, [ 0, 0, 0 ], 0.3/2 ) );
      }

      new_sector.edges = [];
      for (var e = 0; e < sector.edges.length; ++e)
      {
        var edge = sector.edges[e];
        var new_edge = {
          x0: edge.x0, y0: edge.y0,
          x1: edge.x1, y1: edge.y1,
          dest: edge.dest,
          dbg: edge.dbg
        };

        new_edge.len = point_distance(new_edge.x0, new_edge.y0, new_edge.x1, new_edge.y1);

        // Solid walls use lower.
        // Portal walls use lower, upper, middle(optional).
        new_edge.lower = {
          u: edge.tex.l.u,
          v: edge.tex.l.v,
          uscale: 1/edge.tex.l.us,
          vscale: 1/edge.tex.l.vs,
          tex: load_texture('wall', edge.tex.l.n)
        };
        new_edge.middle = {
          u: edge.tex.m.u,
          v: edge.tex.m.v,
          uscale: 1/edge.tex.m.us,
          vscale: 1/edge.tex.m.vs,
          tex: load_texture('wall', edge.tex.m.n)
        };
        new_edge.upper = {
          u: edge.tex.u.u,
          v: edge.tex.u.v,
          uscale: 1/edge.tex.u.us,
          vscale: 1/edge.tex.u.vs,
          tex: load_texture('wall', edge.tex.u.n || edge.tex.l.n)
        };

        new_sector.edges.push(new_edge);
      }

      // Link up the edge 'next' properties, for faster iteration around them
      for (e = 0; e < new_sector.edges.length; ++e)
      {
        new_sector.edges[e].next = new_sector.edges[ (new_sector.edges.length+e-1) % new_sector.edges.length ];
      }

      sectors.push(new_sector);
    }

    // Link up sectors through portal walls
    for (var s = 0; s < sectors.length; ++s)
    {
      for (var e = 0; e < sectors[s].edges.length; ++e)
      {
        var edge = sectors[s].edges[e];
        edge.dest = (edge.dest === 0 ? null : sectors[ edge.dest-1 ]);
      }
    }

    player.s = sectors[player.sector_id];

    // Handle scripted sectors
    for (var s = 0; s < level.sectors.length; ++s)
    {
      if (level.sectors[s].tags)
      {
        for (var t = 0; t < level.sectors[s].tags.length; ++t)
        {
          var tag = level.sectors[s].tags[t];
          if (tag.type == 'vertical door')
          {
            var c = polygon_centre(sectors[s]);
            self.level_data.proximity_triggers.push({
              x: c.x, y: c.y,
              fn: scripted_vertical_door(sectors[s])
            });
          }
          else
          {
            alert('invalid sector tag "' + tag.type + '"');
          }
        }
      }
    }

    // Handle sprites:

    sprites = [];

    for (var s = 0; s < level.sprites.length; ++s)
    {
      var new_sprite = {
        x: level.sprites[s].x,
        y: level.sprites[s].y,
        a: level.sprites[s].a
        // TODO: scaling
      };
      new_sprite.spritedef = load_sprite(level.sprites[s].sprite);
      new_sprite.sector = sectors[level.sprites[s].sector];

      new_sprite.z = level.sprites[s].z + new_sprite.sector.floor_height;


      // Add this sprite to all sectors which contain its bounding circle.
      // TODO: change this so sprites can move
      var r = new_sprite.spritedef.sprite.radius;
      var nearby_sectors = find_nearby_sectors(new_sprite.x, new_sprite.y, new_sprite.sector, r);
      for (var i = 0; i < nearby_sectors.length; ++i)
      {
        nearby_sectors[i].sprites[s] = 1;
      }

      sprites.push(new_sprite);
    }
  }


  function find_nearby_sectors_(x, y, sector, d, found)
  {
    if (found[sector.id])
    {
      return;
    }
    found[sector.id] = true;

    for (var e = 0; e < sector.edges.length; ++e)
    {
      var edge = sector.edges[e];
      if (edge.dest)
      {
        var dist = point_line_distance_circle(x, y, edge.x0, edge.y0, edge.x1, edge.y1);
        if (dist <= d)
        {
          find_nearby_sectors_(x, y, edge.dest, d, found);
        }
      }
    }
  }

  function find_nearby_sectors(x, y, sector, d)
  {
    var found = {};
    find_nearby_sectors_(x, y, sector, d, found);
    var found_sectors = [];
    for (var s in found)
    {
      found_sectors.push(sectors[s]);
    }
    return found_sectors;
  }

  // (dx,dy) is total displacement, t is time in seconds [which is relevant when we add gravity...]
  function move_camera_by(dx, dy, t)
  {
    /*
    Theoretical algorithm:
    - Find all sectors which are 'close' (reachable from edges within r+d of camera).
    - Construct list of edges and vertices, to collide the camera-circle against.
      (This may get things wrong when 'close' sectors are overlapping. So limit the
      distance 'd' to some small maximum, and tell people to not overlap nearby
      sectors.)
    - Push edges inwards by r and expand vertices into circles of size r,
      then collide a camera-point against them.
    - (Assert that d < r/2). Then move the camera to the end point, find any walls it's
      now intersecting, and push the camera out.
    */

    var radius = player.radius;

    var d = Math.sqrt(dx*dx + dy*dy);
    var nearby_sectors = find_nearby_sectors(player.x, player.y, player.s, d+radius);

    for (var s = 0; s < nearby_sectors.length; ++s)
    {
      for (var e = 0; e < nearby_sectors[s].edges.length; ++e)
      {
        var edge = nearby_sectors[s].edges[e];

        // Try colliding against solid/portal wall:

        // If this is a portal wall, check whether we can fit between
        // new sector's floor and ceiling
        if (edge.dest &&
          (player.z+player.maxstep >= edge.dest.floor_height && player.z+player.height <= edge.dest.ceiling_height))
        {
          // okay - can pass
        }
        else
        {
          // Check whether we're on the inside of this edge
          var dir = dx*(edge.y1-edge.y0) - dy*(edge.x1-edge.x0);
          if (dir > 0)
          {
            // Check whether we're too close to the edge
            var dist = point_line_distance_circle(player.x+dx, player.y+dy, edge.x0, edge.y0, edge.x1, edge.y1);
            if (dist < radius)
            {
              // Push outwards along the edge's normal
              var d = radius-dist;
              var nx = edge.y0 - edge.y1;
              var ny = edge.x1 - edge.x0;
              var n = d / Math.sqrt(nx*nx + ny*ny);
              dx += nx*n;
              dy += ny*n;
            }
          }


          // TODO: this is quite broken - it's possible to fly up the corners
          // of objects by running into them. The stuff below doesn't
          // actually help (now that the above look is using _circle instead of _perp),
          // so don't bother with it.

          /*
          // Check whether we're inside circles around the edge's vertices
          // (TODO: this does far too much redundant work)

          var dist = point_distance(player.x+dx, player.y+dy, edge.x0, edge.y0);
          if (dist < radius)
          {
            // Push outwards along the edge's normal
            var d = radius-dist;
            var nx = edge.y0 - edge.y1;
            var ny = edge.x1 - edge.x0;
            var n = d / Math.sqrt(nx*nx + ny*ny);
            dx += nx*n;
            dy += ny*n;
          }

          var dist = point_distance(player.x+dx, player.y+dy, edge.x1, edge.y1);
          if (dist < radius)
          {
            // Push outwards along the edge's normal
            var d = radius-dist;
            var nx = edge.y0 - edge.y1;
            var ny = edge.x1 - edge.x0;
            var n = d / Math.sqrt(nx*nx + ny*ny);
            dx += nx*n;
            dy += ny*n;
          }
          */
        }
      }
    }

    // Now player.(x,y) + (dx,dy) is a valid place to be.

    player.x += dx;
    player.y += dy;

    // Work out which sector it is in. (This is probably more robust than
    // trying to work out which boundaries have been crossed, because the
    // path dx,dy might be jumping outside the level geometry.)

    var new_sectors;

    for (var s = 0; s < nearby_sectors.length; ++s)
    {
      if (point_is_in_polygon(player.x, player.y, nearby_sectors[s]))
      {
        player.s = nearby_sectors[s];
        break;
      }
    }
  }

  function rotate_camera(da)
  {
    var a = Math.atan2(player.dx, player.dy);
    a -= da;
    player.dx = Math.sin(a);
    player.dy = Math.cos(a);
  }

  function move_camera(dx, dy)
  {
    var d = Math.sqrt(dx*dx + dy*dy);
    dx /= d;
    dy /= d;
    var step_size = player.radius / 2;
    while (d >= step_size)
    {
      move_camera_by(dx*step_size, dy*step_size, 1);
      d -= step_size;
    }
    if (d > 0)
    {
      move_camera_by(dx*d, dy*d, 1);
    }
  }

  function walk_camera(forwards, sideways)
  {
    var dx = player.dx*forwards-player.dy*sideways;
    var dy = player.dy*forwards+player.dx*sideways;
    move_camera(dx, dy);
  }

  function jump()
  {
    if (player.on_floor)
    {
      player.vz = 2;
    }
  }

  cursor_move = {'x':0, 'y':0}

  function process_mouse_input(dx, dt) {
    rotate_camera(dx/10000);
    self.current_x = 0;
  }

  function process_input(keys, dt)
  {
    var walk_speed = 1.5;
    var strafe_speed = walk_speed / 2;
    var turn_speed = 1.5;
    var look_speed = 1;

    if (keys[DOM_VK.A]) { rotate_camera(-turn_speed*dt); }
    if (keys[DOM_VK.D]) { rotate_camera( turn_speed*dt); }

    var dx = 0, dy = 0;
    if (keys[DOM_VK.W]) { dx += walk_speed; }
    if (keys[DOM_VK.S]) { dx -= walk_speed; }

    // Opera sends keyCode 44 (Mozilla's DOM_VK_DELETE) for
    // both '.' and 'del'. We can't tell them apart, so just accept
    // 'del' as an alternative strafe key.
    // It also sends 44 (DOM_VK_PRINTSCREEN) for ',', though it doesn't
    // receive the printscreen key at all.
    // And some keyboards (e.g. French AZERTY) seem to require shift+semicolon
    // to get '.', so also allow X/C for strafing.

    if (keys[DOM_VK.COMMA] || keys[DOM_VK.PRINTSCREEN] || keys[DOM_VK.X])
      { dy -= strafe_speed; }
    if (keys[DOM_VK.PERIOD] || keys[DOM_VK.DELETE] || keys[DOM_VK.C])
      { dy += strafe_speed; }

    if (dx || dy)
    {
      // Ensure constant velocity; strafing just changes the direction
      var d = Math.sqrt(dx*dx + dy*dy);
      dx /= d;
      dy /= d;
      walk_camera(dx*walk_speed*dt, dy*walk_speed*dt);
    }

    if (keys[DOM_VK.PAGE_UP])   { player.dh = Math.min(+self.max_vertical_look, player.dh+look_speed*dt); }
    if (keys[DOM_VK.PAGE_DOWN]) { player.dh = Math.max(-self.max_vertical_look, player.dh-look_speed*dt); }

    if (keys[DOM_VK.SPACE]) { jump(); }

    if(keys[DOM_VK.F2]) { lockPointer(); }

    var mx = 0, my = 0;
    if(Math.abs(cursor_move.x) > self.turn_threshold)
      mx = cursor_move.x * (self.max_turn_speed / self.max_mouse_movement) * dt;
    if(Math.abs(cursor_move.y) > self.turn_threshold)
      my = cursor_move.y * (self.max_turn_speed / self.max_mouse_movement) * dt;

    if(mx > 0)
      mx = Math.min(+self.max_turn_speed, mx);
    else if(mx < 0)
      mx = Math.max(-self.max_turn_speed, mx);
    rotate_camera(mx);

    if(my > 0)
      player.dh = Math.min(+self.max_vertical_look, player.dh - my);
    else if(my < 0)
      player.dh = Math.max(-self.max_vertical_look, player.dh - my);
  }

  function do_gravity(dt)
  {
    var gravity_accel = 5;

    var max_floor = -Infinity, min_ceiling = Infinity;

    var r = player.radius - 0.01; // slight fudginess to prevent floating up walls

    var nearby_sectors = find_nearby_sectors(player.x, player.y, player.s, r);

    for (var s = 0; s < nearby_sectors.length; ++s)
    {
      max_floor = Math.max(nearby_sectors[s].floor_height, max_floor);
      min_ceiling = Math.min(nearby_sectors[s].ceiling_height, min_ceiling);
    }

    if (player.z == max_floor && player.vz <= 0)
    {
      // Nothing much to do if they're already standing on the floor
      player.vz = 0;
      player.on_floor = true;
    }
    else
    {
      // Accelerate downwards
      // (Not particularly accurate because we're moving in discrete steps)
      player.vz -= gravity_accel*dt;

      player.on_floor = false;

      if (player.vz > 0)
      {
        // Moving upwards:

        if (player.z + player.vz*dt + player.height <= min_ceiling)
        {
          // Okay to jump up this far
          player.z += player.vz*dt;
        }
        else
        {
          // Stick them to the ceiling
          player.z = min_ceiling-player.height;
          player.vz = 0;
        }
      }
      else if (player.vz < 0)
      {
        // Moving downwards:

        if (player.z + player.vz*dt >= max_floor)
        {
          // Okay to fall down this far
          player.z += player.vz*dt;
        }
        else
        {
          // Stick them to the floor
          player.z = max_floor;
          player.vz = 0;
          player.on_floor = true;
        }
      }
    }
  }

  function process_scripts(dt)
  {
    for (var i = 0; i < self.level_data.proximity_triggers.length; ++i)
    {
      var trigger = self.level_data.proximity_triggers[i];
      var dist = point_distance(trigger.x, trigger.y, player.x, player.y);
      trigger.fn(dt, dist);
    }
  }

  function draw_map(ctx)
  {
    ctx.fillStyle = '#fffff0';
    var w = ctx.canvas.width;
    var h = ctx.canvas.height;
    ctx.fillRect((-map_shift_x-w/2)/map_scale, (-map_shift_y-h/2)/map_scale, w/map_scale, h/map_scale);

    var d = '';

    for (var s = 0; s < sectors.length; ++s)
    {
      var sector = sectors[s];
      for (var e = 0; e < sector.edges.length; ++e)
      {
        var edge = sector.edges[e];

        if (sector == self.camera.s)
        {
          ctx.strokeStyle = '#0000ff';
        }
        else if (edge.dest === null)
        {
          ctx.strokeStyle = '#00ff00';
        }
        else
        {
          ctx.strokeStyle = '#ff0000';
        }
        ctx.beginPath();
        ctx.moveTo(edge.x0, edge.y0);
        ctx.lineTo(edge.x1, edge.y1);
        ctx.stroke();
      }
    }

    ctx.strokeStyle = '#ff00ff';
    ctx.beginPath();
    ctx.moveTo(self.camera.x, self.camera.y);
    ctx.lineTo(self.camera.x+self.camera.dx*0.2, self.camera.y+self.camera.dy*0.2);
    ctx.stroke();
    ctx.closePath();
  }


  function fpsgraph_enable(state)
  {
    if (! fpsgraph_enabled)
    {
      var obj = document.createElementNS('http://www.w3.org/1999/xhtml', 'object');
      obj.width = 640;
      obj.height = 320;
      obj.data = 'fpsgraph/fpsgraph.xhtml';
      obj.id = 'fpsgraph';
      document.getElementById('fpsgraph_container').appendChild(obj);
      document.getElementById('fpsgraph_container').style.display = 'block';
      fpsgraph_enabled = true;
    }
  }

  const STATE_LOADING = 0;
  const STATE_PLAYING = 1;
  var game_state = STATE_LOADING;
  self.game_tick = function(ctx, dctx, gctx, w, h, keys, dt)
  {
    switch (game_state)
    {
    case STATE_LOADING:
      // ...
      break;

    case STATE_PLAYING:
      process_input(keys, dt);
      process_mouse_input(self.current_x, dt);
      do_gravity(dt);
      process_scripts(dt);

      self.camera.x = player.x;
      self.camera.y = player.y;
      self.camera.z = player.z + player.eyeline;
      self.camera.dx = player.dx;
      self.camera.dy = player.dy;
      self.camera.dh = player.dh;
      self.camera.s = player.s;
      self.camera.t += dt;

      if (dctx)
      {
        profile_begin('map');
        draw_map(dctx);
        profile_end('map');
      }

      process_pending_textures(ctx);

      self.renderer.render_frame(ctx, dctx, gctx, w, h, self.camera);

      break;
    }
  };

  self.on_map_loaded = function(ctx, h)
  {
  //  upgrade_level(); // XXX
    self.preprocess_map(ctx, h);

    if (editor_enabled)
    {
      var reload_map = function ()
      {
        self.preprocess_map(ctx, h);
      };

      editor_init(reload_map);
    }

    game_state = STATE_PLAYING;
  }

};

module.exports = new Game();

},{"./options_flags":3,"./renderer":4}],3:[function(require,module,exports){
module.exports = {
  mipmap_max : 7,
  mipmap_min : 3,
  mipmap_enabled : 1,
  texture_u_repeat : 192/128,
  texture_v_repeat : 144/128,
  gradient_surfaces: 1,
  horizontal_scale: 8, // TODO: reimplement
  low_textures: 1, // TODO: reimplement
  map: 1, // TODO: reimplement
  draw_from_canvas: 0,
  draw_pattern_walls: 0, // Opera: no difference; FF1.5: no diff; FF2.0: no diff, or slightly slower?; FF3.0: ~10% slower but fixes black line between textures
  no_alpha_texture: 0,
  opera_context: 0, // doesn't work
  opera_hack: 1, // doesn't work either
  double_buffer: 1,
  textured_floors: 1, // only suitable for testing
  textured_ceilings: 0 // only suitable for testing
};

},{}],4:[function(require,module,exports){
/*
 * Copyright 2006 Philip Taylor
 * <philip at zaynar.demon.co.uk> / <excors at gmail.com>
 * Distributed under the terms of the GPL (http://www.gnu.org/licenses/gpl.txt)
 */

var Renderer = function(options_flags) {
	var self = this;
	self.sectors = null;
	self.sprites = null;

	const mipmap_bias = -0.5;

	const near_clip = 0.01;

	// dx, dy, dw, dh: integer
	// fills dx,dy (inclusive) -> dx+dw,dy+dh (exclusive)
	// u1, sy, u1, sh: float
	function draw_texture_strip(ctx, tex, u0,sy,u1,sh, dx,dy,dw,dh)
	{
		while (u1 >= options_flags.texture_u_repeat)
		{
			var d = Math.floor(dw*(1-u0)/(u1-u0));
			ctx.drawImage(tex.img, tex.w*u0, tex.h*sy, tex.w*(1-u0), tex.h*sh, dx, dy, d, dh);
	//		ctx.strokeStyle='#ff0000'; ctx.strokeRect(dx,dy,d,dh);

			dx += d;
			dw -= d;
			u0 = 0;
			u1 -= 1;
		}
		ctx.drawImage(tex.img, tex.w*u0, tex.h*sy, tex.w*(u1-u0), tex.h*sh, dx, dy, dw, dh);
	//	ctx.strokeStyle='#ff0000'; ctx.strokeRect(dx,dy,dw,dh);
	}

	function get_mip(tex, s)
	{
		var miplevel = Math.ceil(mipmap_bias + Math.log(s)/Math.LN2);
		if (miplevel < options_flags.mipmap_min)
		{
			miplevel = options_flags.mipmap_min;
		}
		else if (miplevel >= tex.length)
		{
			miplevel = tex.length-1;
		}
		else if (isNaN(miplevel))
		{
			miplevel = options_flags.mipmap_min;
		}

		return tex[miplevel];
	}

	function get_mip_level(tex, s)
	{
		var miplevel = Math.ceil(mipmap_bias + Math.log(s)/Math.LN2);
		if (miplevel < options_flags.mipmap_min)
		{
			miplevel = options_flags.mipmap_min;
		}
		else if (miplevel >= tex.length)
		{
			miplevel = tex.length-1;
		}
		else if (isNaN(miplevel))
		{
			miplevel = options_flags.mipmap_min;
		}

		return miplevel;
	}

	function draw_texture(ctx, h, clip_y0, clip_y1, tex, sx,sy,sw,sh, dx,dy,dw,dh)
	{
		var miptex;
		if (sw < 1e-6) { return; }

		if (options_flags.draw_pattern_walls)
		{
			miptex = get_mip(tex, dw/sw);
			try{ // TODO - need to fix default textures here

				ctx.save();
				ctx.fillStyle = miptex.img;

				ctx.scale(dw/(sw*miptex.w), dh/(sh*miptex.h));
				ctx.translate((dx*sw/dw-sx)*miptex.w, (dy*sh/dh-sy)*miptex.h);
				ctx.fillRect(sx*miptex.w, sy*miptex.h, sw*miptex.w, sh*miptex.w);

	//	ctx.strokeStyle='#ff0000'; ctx.strokeRect(sx*miptex.w, sy*miptex.h, sw*miptex.w, sh*miptex.w);

				ctx.restore();

			}catch(e){debug(e);}
		}
		else
		{

			var u0 = (sx<0 ? 1+sx%1 : sx%1);
			var v0 = (sy<0 ? 1+sy%1 : sy%1);
			var v1 = v0+sh;

			while (v1 >= options_flags.texture_v_repeat)
			{
				var d = Math.floor(dh*(1-v0)/(v1-v0));
				if (dy < clip_y1 && dy+d >= clip_y0 && d > 0)
				{
					if (! miptex) { miptex = get_mip(tex, dw/sw); }
					draw_texture_strip(ctx, miptex, u0, v0, u0+sw, 1-v0, dx, dy, dw, d);
				}
				dy += d;
				dh -= d;
				v0 = 0;
				v1 -= 1;
			}

			if (dy < clip_y1 && dy+dh >= clip_y0 && dh > 0)
			{
				if (! miptex) { miptex = get_mip(tex, dw/sw); }
				draw_texture_strip(ctx, miptex, u0, v0, u0+sw, v1-v0, dx, dy, dw, dh);
			}
		}
	//	ctx.strokeStyle='#ff0000';ctx.strokeRect(dx,dy,dw,dh);
	}

	// Helper function to sort sprites by depth
	function sprite_sort(a, b)
	{
		return (a.w > b.w ? -1 : a.w < b.w ? 1 : 0);
	}

	// Draw sprites inside sector, clipped to x0 (inclusive) - x1 (exclusive)
	function render_sprites(ctx, camera, sector, x0, x1, w, h)
	{
		var sorted_sprites = [];
		for (var s in sector.sprites)
		{
			var sprite = sprites[s];
			var depth = point_depth(camera.x, camera.y, camera.dx, camera.dy, sprite.x, sprite.y);
			if (depth > 0)
			{
				sorted_sprites.push({ sprite:sprite, w:depth });
			}
		}

		sorted_sprites.sort(sprite_sort);

		ctx.beginPath(); // XXX hack for FF1.5, 2.0b1

		for (var s = 0; s < sorted_sprites.length; ++s)
		{
			var sprite = sorted_sprites[s].sprite;
			var depth = sorted_sprites[s].w;

			var numframes = sprite.spritedef.sprite.frames;
			var numangles = sprite.spritedef.sprite.angles;
			var frame = Math.floor(camera.t*1000 / sprite.spritedef.sprite.speed) % numframes;
			var angle = Math.PI + sprite.a - Math.atan2(sprite.y-camera.y, sprite.x-camera.x);
			angle = (numangles + Math.round(angle * numangles / (2 * Math.PI))) % numangles;
			var tex = sprite.spritedef.images[frame + angle*numframes];

			var x = w*(0.5 + uncast_ray(sprite.x, sprite.y, camera));
			var height = h*(sprite.spritedef.sprite.height / depth);
			var width = height * tex.w / tex.h;

			var clipped_x0 = x-width/2;
			var clipped_x1 = x+width/2;
			if (clipped_x0 < x1 && clipped_x1 > x0)
			{
				var zbase = h*(0.5 - (-camera.z + sprite.z) / depth);
				var u0 = 0, u1 = 1;

				if (clipped_x0 < x0)
				{
					u0 = (x0 - clipped_x0) / width;
					clipped_x0 = x0;
				}
				if (clipped_x1 > x1)
				{
					u1 = 1 - (clipped_x1 - x1) / width;
					clipped_x1 = x1;
				}
				ctx.drawImage(tex.img, u0*tex.w, 0, (u1-u0)*(tex.w-0.01), tex.h, clipped_x0, zbase-height, clipped_x1-clipped_x0, height);
			}
		}
	}

	function render(w, h, ctx, dctx, camera)
	{
		var dh = Math.floor(camera.dh * h); // integer translations are much faster
		if (dh !== 0)
		{
			ctx.save();
			ctx.translate(0, dh);
		}

		render_rays(0, w, -dh, h-dh, camera.s, w, h, ctx, dctx, camera, 0);

		if (dh !== 0)
		{
			ctx.restore();
		}
	}

	function max_abs(x, y)
	{
		x = Math.abs(x);
		y = Math.abs(y);
		return x > y ? x : y;
	}

	// Clips to (x,clip_y0)inclusive -> (edge_end,clip_y1)exclusive (but may overshoot in the vertical direction)
	function draw_poly(ctx, h, tex, x, edge_end, clip_y0, clip_y1, bot0, top0, bot1, top1, w0, w1, u0, u1, v0, v1, floor, ceiling, lighting, solid)
	{
		if (w0 < near_clip || w1 < near_clip)
		{
			return;
		}

	/*
	ctx.strokeStyle = '#ffffff';
	ctx.beginPath();
	ctx.moveTo(x, top0);
	ctx.lineTo(x, bot0);
	ctx.lineTo(edge_end, bot1);
	ctx.lineTo(edge_end, top1);
	ctx.closePath();
	ctx.stroke();

		if (floor && (top0 < clip_y1 || top1 < clip_y1))
		{
			ctx.strokeStyle = '#ff0000';
			ctx.beginPath();
			ctx.moveTo(x, clip_y1-1);
			ctx.lineTo(x, top0);
			ctx.lineTo(edge_end, top1);
			ctx.lineTo(edge_end, clip_y1-1);
			ctx.closePath();
			ctx.stroke();
		}
		if (ceiling && (bot0 >= clip_y0 || bot1 >= clip_y0))
		{
			ctx.strokeStyle = '#00ff00';
			ctx.beginPath();
			ctx.moveTo(x, clip_y0);
			ctx.lineTo(x, bot0);
			ctx.lineTo(edge_end, bot1);
			ctx.lineTo(edge_end, clip_y0);
			ctx.closePath();
			ctx.stroke();
		}
		if (floor || ceiling)
		{
			// TODO: why do I need this?
			ctx.beginPath();
		}

	*/
		ctx.beginPath(); // XXX hack for FF1.5, 2.0b1

		// Apply texture offsets
		u0 = u0*tex.uscale + tex.u;
		u1 = u1*tex.uscale + tex.u;
		v0 = v0*tex.vscale + tex.v;
		v1 = v1*tex.vscale + tex.v;

		var u0w = u0 / w0;
		var u1w = u1 / w1;

		var dtop = (top1-top0) / (edge_end-x);
		var dbot = (bot1-bot0) / (edge_end-x);
		var dt = 1 / (edge_end-x);
		var t = 0;
		var top = top0;
		var bot = bot0;
		var xp = x;

		var max_dy = 2;
		var min_dx = 8;
		var max_dx = Infinity;

		// dx*dtop = max_dy
		// dx*dbot = max_dy
		// => dx*max_abs(dtop, dbot) = max_dy
		// => dx = max_dy/max(dtop, dbot)

		var dy = max_abs(dtop, dbot);
		var dx = Math.floor(max_dy / dy);
		if (dx < min_dx) { dx = min_dx; }
		if (dx > max_dx) { dx = max_dx; }
		// Avoid jagged edges by ensuring the rectangles are sized to the outside
		// of the polygon, rather than the inside.
		if (dtop > 0) { top += dtop*dx; }
		if (dbot < 0) { bot += dbot*dx; }

		var alpha_texture = !(solid && !options_flags.no_alpha_texture);

		if (!alpha_texture && lighting < 1)
		{
			ctx.globalAlpha = lighting;
		}

		if (! solid)
		{
			// XXX - workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=347458
			ctx.beginPath();
			ctx.rect(0, 0, 0, 0);
			ctx.stroke();

			ctx.save();
			ctx.beginPath();
			ctx.moveTo(x, bot0);
			ctx.lineTo(edge_end, bot1);
			ctx.lineTo(edge_end, top1);
			ctx.lineTo(x, top0);
			ctx.clip();
		}

		var u = u0;
		while (xp < edge_end)
		{
			profile_count("draw strip");

			if (xp + dx > edge_end) { dx = edge_end - xp; }

			t += dx*dt;

			if (top >= clip_y0 && bot < clip_y1)
			{
				if (v1 > v0)
				{
					var topi = Math.floor(top);
					var boti = Math.floor(bot);
					var ul = u;
					u = ( (1-t)*u0w + t*u1w ) / ( (1-t)/w0 + t/w1 );
					draw_texture(ctx, h, clip_y0, clip_y1, tex.tex, ul, v0, u-ul, v1-v0,  xp, boti, dx, topi-boti+1);

					if (alpha_texture && lighting < 1)
					{
						ctx.fillStyle = '#000000';
						ctx.globalAlpha = 1-lighting;
						ctx.fillRect(xp, boti, dx, topi-boti+1);
						ctx.globalAlpha = 1;
					}
				}
			}
			xp += dx;
			top += dx*dtop;
			bot += dx*dbot;
		}

		if (! solid)
		{
			ctx.restore();
		}

		if (!alpha_texture && lighting < 1)
		{
			ctx.globalAlpha = 1;
		}

		if (floor && (top0 < clip_y1 || top1 < clip_y1))
		{
			if (! options_flags.textured_floors)
			{
				ctx.fillStyle = floor;
				//ctx.fillStyle = 'rgba(255,255,255,0.5)';
				ctx.beginPath();
				ctx.moveTo(x, clip_y1);
				ctx.lineTo(x, top0);
				ctx.lineTo(edge_end, top1);
				ctx.lineTo(edge_end, clip_y1);
				ctx.fill();
			}
		}
		if (ceiling && (bot0 >= clip_y0 || bot1 >= clip_y0))
		{
			ctx.fillStyle = ceiling;
			//ctx.fillStyle = 'rgba(255,255,255,0.5)';
			ctx.beginPath();
			ctx.moveTo(x, clip_y0-1);
			ctx.lineTo(x, bot0);
			ctx.lineTo(edge_end, bot1);
			ctx.lineTo(edge_end, clip_y0-1);
			ctx.fill();
		}

		//*/
	}

	function draw_floor(dctx, ctx, h, w, camera, isctn0, isctn1, sector, clip_y, x0, x1, y0, y1)
	{
		const step = 2;
		const r = 2*32;

		var z = sector.floor_height-camera.z;

		// XXX - workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=347458
		ctx.beginPath();
		ctx.rect(0, 0, 0, 0);
		ctx.stroke();

		ctx.save();

		ctx.beginPath();
		ctx.moveTo(x0, y0);
		ctx.lineTo(x1, y1);
		ctx.lineTo(x1, clip_y);
		ctx.lineTo(x0, clip_y);
		ctx.closePath();
		ctx.clip();

		for (var screeny = Math.floor(Math.min(y0, y1)); screeny < clip_y; screeny += step)
		{
			/*
			screeny = h*(0.5 - z/d);
			=> z = d*(0.5 - screeny/h);
			=> d = z/(0.5 - screeny/h);
			*/
			var d = z / (0.5 - screeny/h);
			var c0 = ray_coords(d, x0/w-0.5, camera);
			var c1 = ray_coords(d, x1/w-0.5, camera);

			/*
			if (x0){
				dctx.fillStyle='#000000';
				dctx.fillRect(c0.x, c0.y, 0.15, 0.15);
				dctx.fillRect(c1.x, c1.y, 0.15, 0.15);
			}
			*/

			// c0*r = uv0 is UV coords of left point, c1*r of right
			// s0 is [x0, sy], s1 is [x1, sy]

			// Need M*uv0*128 = s0, M*uv1*128 = s1
			// => (M*128)*(uv0-uv1) = s0-s1

			// M*128 = scale(|s0-s1| / |uv0-uv1|) * rotate(-atan2(v0-v1, u0-u0))
			// M = scale(|s0-s1| / |uv0-uv1| / 128) * rotate(-atan2(v0-v1, u0-u0)) * translate(tx, ty)

			// M*uv0*128 = s0
			// => scale(|s0-s1| / |uv0-uv1|) * rotate(-atan2(v0-v1, u0-u0)) * translate(tx, ty) * uv0 = s0
			// => translate(tx, ty) * uv0 = (scale(|s0-s1| / |uv0-uv1|) * rotate(-atan2(v0-v1, u0-u0)))^-1 * s0
			// => translate(tx, ty) * uv0 = scale(|uv0-uv1| / |s0-s1|) * rotate(atan2(v0-v1, u0-u0)) * s0
			// => [tx, ty] = scale(|uv0-uv1| / |s0-s1|) * rotate(atan2(v0-v1, u0-u0)) * s0 - uv0

			var s_over_uv = (x1-x0) / (r * point_distance(c0.x, c0.y, c1.x, c1.y));

			var angle = Math.atan2(c0.y-c1.y, c0.x-c1.x);
			var cos_scaled = Math.cos(angle) / s_over_uv;
			var sin_scaled = Math.sin(angle) / s_over_uv;

			var tx = (cos_scaled*x0 - sin_scaled*screeny) + c0.x*r;
			var ty = (sin_scaled*x0 + cos_scaled*screeny) + c0.y*r;

			var y0b = screeny;
			var y1b = screeny+step;
			var x0b = x0;
			var x0c = x0;
			var x1b = x1;
			var x1c = x1;

			var mip = get_mip_level(sector.floor, s_over_uv/48);
			var s = 128 / Math.pow(2, mip);

			ctx.fillStyle = sector.floor[mip].img;

			ctx.save();
			ctx.scale(s_over_uv*s, s_over_uv*s);
			ctx.rotate(-angle);
			ctx.translate(tx/s, ty/s);
			ctx.beginPath();
			ctx.moveTo((x0c*cos_scaled-y1b*sin_scaled-tx)/s, (x0c*sin_scaled+y1b*cos_scaled-ty)/s);
			ctx.lineTo((x0b*cos_scaled-y0b*sin_scaled-tx)/s, (x0b*sin_scaled+y0b*cos_scaled-ty)/s);
			ctx.lineTo((x1b*cos_scaled-y0b*sin_scaled-tx)/s, (x1b*sin_scaled+y0b*cos_scaled-ty)/s);
			ctx.lineTo((x1c*cos_scaled-y1b*sin_scaled-tx)/s, (x1c*sin_scaled+y1b*cos_scaled-ty)/s);
			ctx.fill();
			ctx.restore();
		}

		ctx.restore();
	}

	// Draw between pixel coordinates x0 (inclusive), x1 (exclusive)
	function render_rays(x0, x1, y0, y1, sector, w, h, ctx, dctx, camera, limit)
	{
		var x = x0;

		var isctn0 = cast_ray(sector, x/w-0.5, camera);

		while (x < x1)
		{
			profile_count("cast strip");

			if (dctx)
			{
				var px = x/w - 0.5;
				dctx.strokeStyle = '#ff0000';
				dctx.beginPath();
				dctx.moveTo(camera.x, camera.y);
				dctx.lineTo(camera.x+camera.dx-px*camera.dy, camera.y+camera.dy+px*camera.dx);
				dctx.stroke();
			}

			var edge = isctn0.edge;
			if (! edge)
			{
				// TODO: this shouldn't happen, but it does if we're
				// right on the edge of a sector looking outwards
				ctx.fillStyle = '#000000';
				ctx.fillRect(x, 0, 1, h);
				//debug("no edge "+camera.dx+","+camera.dy);
				++x;

				isctn0 = cast_ray(sector, x/w-0.5, camera);
			}
			else
			{
				if (dctx)
				{
					dctx.strokeStyle = '#0000ff';
					dctx.beginPath();
					dctx.moveTo(camera.x, camera.y);
					dctx.lineTo(edge.x1, edge.y1);
					dctx.stroke();
				}

				// edge_end: exclusive pixel coord
				var edge_end = Math.floor(1+w*(0.5 + uncast_ray(edge.x1, edge.y1, camera)));

				var isctn1;
				// Clip to viewport rectangle
				if (edge_end > x1)
				{
					edge_end = x1;
					isctn1 = cast_ray_edge(edge, x1/w-0.5, camera);
				}
				else
				{
					isctn1 = { dist: point_depth(camera.x, camera.y, camera.dx, camera.dy, edge.x1, edge.y1), u: edge.len };
				}

				if (edge.dest === null)
				{
					// Solid wall

					var bottom0 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn0.dist);
					var top0    = h*(0.5 - (-camera.z + sector.floor_height)/isctn0.dist);
					var bottom1 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn1.dist);
					var top1    = h*(0.5 - (-camera.z + sector.floor_height)/isctn1.dist);

					var w0 = isctn0.dist;
					var w1 = isctn1.dist;
					var u0 = isctn0.u;
					var u1 = isctn1.u;
					var v0 = -sector.ceiling_height;
					var v1 = -sector.floor_height;

					draw_poly(ctx, h, edge.lower, x, edge_end, y0, y1, bottom0, top0, bottom1, top1, w0, w1, u0, u1, v0, v1, sector.floor, sector.ceiling, sector.light, true);

					if (options_flags.textured_floors)
					{
						draw_floor(dctx, ctx, h, w, camera, isctn0, isctn1, sector, y1, x, edge_end, top0, top1);
					}
				}
				else
				{
					// Portal wall

					// Recursively draw what we can see through this hole
					var bottom0 = h*(0.5 - (-camera.z + Math.max(sector.floor_height, edge.dest.floor_height))/isctn0.dist);
					var top0    = h*(0.5 - (-camera.z + Math.min(sector.ceiling_height, edge.dest.ceiling_height))/isctn0.dist);
					var bottom1 = h*(0.5 - (-camera.z + Math.max(sector.floor_height, edge.dest.floor_height))/isctn1.dist);
					var top1    = h*(0.5 - (-camera.z + Math.min(sector.ceiling_height, edge.dest.ceiling_height))/isctn1.dist);

					var y0r = Math.min(top0, top1);
					var y1r = Math.max(bottom0+1, bottom1+1);
					if (y0r <= y1r && y1r >= y0 && y0r < y1)
					{
						// It's possible to do some precise clipping here, to avoid any overdraw,
						// but in practice it seems to be slower than drawing nice rectangles
						/*
						ctx.save();
						ctx.beginPath();
						ctx.moveTo(x, top0);
						ctx.lineTo(edge_end, top1);
						ctx.lineTo(edge_end, bottom1);
						ctx.lineTo(x, bottom0);
						ctx.clip();
						*/
						render_rays(x, edge_end, Math.max(y0, y0r), Math.min(y1, y1r), edge.dest, w, h, ctx, dctx, camera, limit);
						/*
						ctx.restore();
						*/
					}

					var w0 = isctn0.dist;
					var w1 = isctn1.dist;
					var u0 = isctn0.u;
					var u1 = isctn1.u;

					if (edge.middle.tex)
					{
						var v0 = -sector.ceiling_height;
						var v1 = -sector.floor_height;

						var bottom0 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn0.dist);
						var top0    = h*(0.5 - (-camera.z + sector.floor_height)/isctn0.dist);
						var bottom1 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn1.dist);
						var top1    = h*(0.5 - (-camera.z + sector.floor_height)/isctn1.dist);

						draw_poly(ctx, h, edge.middle, x, edge_end, y0, y1, bottom0, top0, bottom1, top1, w0, w1, u0, u1, v0, v1, null, null, sector.light, false);
					}

					// TODO: don't calculate so much redundant stuff when we can't see
					// the floor/ceiling edge-walls

					// Lower parts of portal walls:
					var bottom0 = h*(0.5 - (-camera.z + edge.dest.floor_height)/isctn0.dist);
					var top0    = h*(0.5 - (-camera.z + sector.floor_height)/isctn0.dist);
					var bottom1 = h*(0.5 - (-camera.z + edge.dest.floor_height)/isctn1.dist);
					var top1    = h*(0.5 - (-camera.z + sector.floor_height)/isctn1.dist);

					var v1 = -sector.floor_height;
					var v0 = -edge.dest.floor_height;

					draw_poly(ctx, h, edge.lower, x, edge_end, y0, y1, bottom0, top0, bottom1, top1, w0, w1, u0, u1, v0, v1, sector.floor, null, sector.light, false);

					if (options_flags.textured_floors)
					{
						draw_floor(dctx, ctx, h, w, camera, isctn0, isctn1, sector, y1, x, edge_end, top0, top1);
					}


					// Upper parts of portal walls:
					var bottom0 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn0.dist);
					var top0    = h*(0.5 - (-camera.z + edge.dest.ceiling_height)/isctn0.dist);
					var bottom1 = h*(0.5 - (-camera.z + sector.ceiling_height)/isctn1.dist);
					var top1    = h*(0.5 - (-camera.z + edge.dest.ceiling_height)/isctn1.dist);

					var v1 = -edge.dest.ceiling_height;
					var v0 = -sector.ceiling_height;

					draw_poly(ctx, h, edge.upper, x, edge_end, y0, y1, bottom0, top0, bottom1, top1, w0, w1, u0, u1, v0, v1, null, sector.ceiling, sector.light, false);
				}

				if (edge_end > x)
				{
					x = edge_end;
					if (x < x1)
					{
						isctn0 = cast_ray(sector, x/w-0.5, camera);
					}
				}
				else
				{
					// This doesn't happen very often, but zero-width walls would cause it
					++x;
					if (x < x1)
					{
						isctn0 = {
							edge: edge.next,
							dist: point_depth(camera.x, camera.y, camera.dx, camera.dy, edge.next.x0, edge.next.y0),
							u: 0
						};
					}
				}
			}
		}

		// XXX - workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=347458
		ctx.beginPath();
		ctx.rect(0, 0, 0, 0);
		ctx.stroke();

		render_sprites(ctx, camera, sector, x0, x1, w, h);
	}

	function uncast_ray(x, y, camera)
	{
		x -= camera.x;
		y -= camera.y;
		var y2 = x*camera.dx + y*camera.dy;
		if (y2 <= 0) { return Infinity; }
		var x2 = x*camera.dy - y*camera.dx;
		return -x2/y2;
	}

	function cast_ray(sector, px, camera)
	{
		var ray_dx = camera.dx-camera.dy*px;
		var ray_dy = camera.dy+camera.dx*px;
		var mag = Math.sqrt(ray_dx*ray_dx + ray_dy*ray_dy);
		ray_dx /= mag;
		ray_dy /= mag;

		var ray_x = camera.x;
		var ray_y = camera.y;

		var closest_edge = null, closest_t, closest_dist2;
		var closest_dist = Infinity;

		for (var e = 0; e < sector.edges.length; ++e)
		{
			var edge = sector.edges[e];

			var t = ray_vs_line(ray_x, ray_y, ray_dx, ray_dy, edge.x0, edge.y0, edge.x1, edge.y1);
			if (t >= 0 && t < 1)
			{
				var side = (camera.x-edge.x0)*(edge.y1-edge.y0) - (camera.y-edge.y0)*(edge.x1-edge.x0);
				if (side < 0)
				{
					var dist = line_depth(camera.x, camera.y, camera.dx, camera.dy, edge.x0, edge.y0, edge.x1, edge.y1, t);
					if (dist > 0 && dist < closest_dist)
					{
						closest_edge = edge;
						closest_t = t;
						closest_dist = dist;
					}
				}
			}
		}

		if (closest_edge)
		{
			var u = closest_t * closest_edge.len;
		}
		return { edge:closest_edge, dist:closest_dist, u:u };
	}

	function cast_ray_edge(edge, px, camera)
	{
		var ray_dx = camera.dx-camera.dy*px;
		var ray_dy = camera.dy+camera.dx*px;
		var mag = Math.sqrt(ray_dx*ray_dx + ray_dy*ray_dy);
		ray_dx /= mag;
		ray_dy /= mag;

		var ray_x = camera.x;
		var ray_y = camera.y;

		var t = ray_vs_line(ray_x, ray_y, ray_dx, ray_dy, edge.x0, edge.y0, edge.x1, edge.y1);
		var dist = line_depth(camera.x, camera.y, camera.dx, camera.dy, edge.x0, edge.y0, edge.x1, edge.y1, t);

		var u = t * edge.len;
		return { edge:edge, dist:dist, u:u };
	}

	function ray_coords(depth, px, camera)
	{
		var ray_dx = camera.dx-camera.dy*px;
		var ray_dy = camera.dy+camera.dx*px;
		depth /= camera.dx*ray_dx + camera.dy*ray_dy;

		return { x: camera.x+depth*ray_dx, y: camera.y+depth*ray_dy };
	}


	self.render_frame = function(ctx, dctx, gctx, w, h, camera)
	{
		// Clear the screen to black (necessary for drawing alpha-lit walls)
		ctx.globalAlpha = 1;
		ctx.fillStyle = '#000000';
		ctx.fillRect(0, 0, w, h);

		profile_begin('render');

		render(w, h, ctx, dctx, camera);

		//	ctx.strokeStyle='#ff0000';ctx.strokeRect(1,1,1,1);

		profile_end('render');

		if (gctx)
		{
			// The suggested way:
			if (! options_flags.opera_hack)
			{
				gctx.lockCanvasUpdates(false);
				gctx.updateCanvas();
				gctx.lockCanvasUpdates(true);
			}
			// but that doesn't work (at least for me, with Opera 9 on Windows) - the
			// canvas is never updated.
			// Sometimes it helps to modify the content of an HTML element to force
			// things to be redisplayed. But sometimes it works magically anyway. *shrug*
			else
			{
				//document.getElementById('opera_hack').innerHTML = '';
				document.getElementById('c').style.width = (document.getElementById('c').style.width == '640px' ? '639px' : '640px');
			}
		}
	}

	var paused_img;
	function render_paused(ctx, w, h)
	{
		if (! paused_img)
		{
			paused_img = new Image();
			paused_img.src = 'static/textures/misc/paused.png';
		}
		if (! paused_img.complete)
		{
			// We can't just add an onload event, because there's a chance it could load
			// between the .complete test and the event addition (and so it'd miss the
			// event).
			// So just try again in a short while.
			setTimeout(render_paused, 100, ctx, w, h);
			return;
		}

		var dw = w * 0.8;
		var dh = dw * (paused_img.height / paused_img.width);
		ctx.globalAlpha = 0.3;
		ctx.fillStyle = '#000000';
		ctx.fillRect(0, 0, w, h);
		ctx.globalAlpha = 1;
		ctx.drawImage(paused_img, (w-dw)/2, (h-dh)/2, dw, dh);
	}
};

module.exports = Renderer;

},{}]},{},[1]);
